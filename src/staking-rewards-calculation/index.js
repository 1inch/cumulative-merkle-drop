import "isomorphic-unfetch"
import { createClient, gql } from "@urql/core"
import BigNumber from "bignumber.js"

const SECONDS_IN_YEAR = 31536000

async function getEpochById(gqlClient, epochId) {
  let data

  const FIRST_EPOCH_QUERY = gql`
    query FirstEpoch($id: String) {
      epoch(id: $id) {
        id
        timestamp
        duration
        totalAmount
      }
    }
  `

  await gqlClient
    .query(FIRST_EPOCH_QUERY, { id: epochId.toString() })
    .toPromise()
    .then((result) => {
      data = result.data.epoch
    })

  return data
}

async function getEpochByIdAndOwner(gqlClient, epochId, address) {
  let data

  // TODO: Max amount of items you can get in a query is 100.
  // adding 'first: 1000' is a WA to get more than 100 stakes,
  // but the most correct option is to use GraphQL pagination.
  const FIRST_EPOCH_QUERY = gql`
    query FirstEpoch($id: String, $address: String) {
      epoch(id: $id) {
        id
        timestamp
        duration
        totalAmount
        stakes(first: 1000, where: { owner: $address }) {
          amount
          stakingProvider
        }
      }
    }
  `

  await gqlClient
    .query(FIRST_EPOCH_QUERY, { id: epochId.toString(), address: address })
    .toPromise()
    .then((result) => {
      data = result.data.epoch
    })

  return data
}

async function getEpochsByStartTime(gqlClient, timestamp) {
  let data

  // TODO: Max amount of items you can get in a query is 100.
  // adding 'first: 1000' is a WA to get more than 100 stakes,
  // but the most correct option is to use GraphQL pagination.
  const ONGOING_STAKES_QUERY = gql`
    query OngoingStakesJuneFirst($timestamp: String) {
      epoches(
        first: 1000
        orderBy: timestamp
        where: { timestamp_gte: $timestamp }
      ) {
        id
        timestamp
        duration
        totalAmount
      }
    }
  `

  await gqlClient
    .query(ONGOING_STAKES_QUERY, { timestamp: timestamp.toString() })
    .toPromise()
    .then((result) => {
      data = result.data.epoches
    })

  return data
}

async function getEpochsBetweenDatesByOwner(
  gqlClient,
  address,
  startTimestamp,
  endTimestamp
) {
  let data

  // TODO: Max amount of items you can get in a query is 100.
  // adding 'first: 1000' is a WA to get more than 100 stakes,
  // but the most correct option is to use GraphQL pagination.
  const ONGOING_STAKES_QUERY = gql`
    query OngoingStakes(
      $address: String
      $startTimestamp: String
      $endTimestamp: String
    ) {
      epoches(
        first: 1000
        orderBy: timestamp
        where: { timestamp_gte: $startTimestamp, timestamp_lte: $endTimestamp }
      ) {
        id
        timestamp
        duration
        totalAmount
        stakes(first: 1000, where: { owner: $address }) {
          amount
          stakingProvider
        }
      }
    }
  `

  await gqlClient
    .query(ONGOING_STAKES_QUERY, {
      address: address,
      startTimestamp: startTimestamp.toString(),
      endTimestamp: endTimestamp.toString(),
    })
    .toPromise()
    .then((result) => {
      data = result.data.epoches
    })

  return data
}

async function getOperatorConfirmedTimestamp (stakingProviderAddress) {

}

/**
 * Get the total ongoing rewards generated by stakes since a specific date
 * @param {string}  gqlURL          Subgraph GraphQL API URL
 * @param {Number} startTimestamp   Start date UNIX timestamp
 * @return {BigNumber}              The amount of generated rewards
 */
async function getTotalOngoingRewards(gqlUrl, timestamp) {
  const currentTime = parseInt(Date.now() / 1000)
  const gqlClient = createClient({ url: gqlUrl })

  let epochs = await getEpochsByStartTime(gqlClient, timestamp)
  const firstEpochId = parseInt(epochs[0].id) > 0 ? epochs[0].id - 1 : 0
  let firstEpoch = await getEpochById(gqlClient, firstEpochId)
  epochs = [firstEpoch, ...epochs]

  epochs[0].timestamp = timestamp.toString()
  epochs[0].duration = (epochs[1].timestamp - timestamp).toString()

  const reward = epochs.reduce((total, epoch) => {
    const amount = new BigNumber(epoch.totalAmount)
    const duration = epoch.duration
      ? parseInt(epoch.duration)
      : currentTime - epoch.timestamp
    const epochReward = amount
      .times(15)
      .times(duration)
      .div(SECONDS_IN_YEAR * 100)
    return total.plus(epochReward)
  }, new BigNumber(0))

  return reward
}

/**
 * Get the ongoing rewards of an stake generated between two dates
 * @param {string}  gqlURL          Subgraph GraphQL API URL
 * @param {string}  ownerAddress    Stake owner address
 * @param {Number}  startTimestamp  Start date UNIX timestamp
 * @param {Number}  endTimestamp    End date UNIX timestamp
 * @return {BigNumber}              The amount of generated rewards
 */
async function getOngoingRewards(
  gqlUrl,
  ownerAddress,
  startTimestamp,
  endTimestamp
) {
  const currentTime = parseInt(Date.now() / 1000)
  const gqlClient = createClient({ url: gqlUrl })

  let epochs = await getEpochsBetweenDatesByOwner(
    gqlClient,
    ownerAddress,
    startTimestamp,
    endTimestamp
  )

  const firstEpochId = parseInt(epochs[0].id) > 0 ? epochs[0].id - 1 : 0
  const firstEpoch = await getEpochByIdAndOwner(
    gqlClient,
    firstEpochId,
    ownerAddress
  )

  epochs = [firstEpoch, ...epochs]
  epochs[0].timestamp = startTimestamp.toString()
  epochs[0].duration = (epochs[1].timestamp - startTimestamp).toString()
  const lastEpochIndex = epochs.length - 1 > 0 ? epochs.length - 1 : 0
  epochs[lastEpochIndex].duration =
    endTimestamp - epochs[lastEpochIndex].timestamp

  // Clean the empty epochs
  epochs = epochs.filter((epoch) => {
    return epoch.stakes.length > 0
  })

  // Sort the epoch's stakes by staking provider
  const stakeList = {}
  epochs.forEach((epoch, index) => {
    epoch.stakes.forEach((stake) => {
      const stakeData = {}
      stakeData.epochTotalAmount = epoch.totalAmount
      stakeData.epochDuration = epoch.duration
      stakeData.epochTimestamp = epoch.timestamp
      stakeData.amount = stake.amount
      stakeList[stake.stakingProvider] = stakeList[stake.stakingProvider]
        ? stakeList[stake.stakingProvider]
        : []
      stakeList[stake.stakingProvider].push(stakeData)
    })
  })

  const rewards = []

  // Calculate the rewards of each stake
  // Rewards formula: r = (s_1 * y_t) * t / 365; where y_t is 0.15
  Object.keys(stakeList).map((stakingProvider) => {
    const stake = stakeList[stakingProvider]
    const reward = stake.reduce((total, epochStake) => {
      const stakeAmount = BigNumber(epochStake.amount)
      const epochDuration = epochStake.epochDuration
        ? parseInt(epochStake.epochDuration)
        : currentTime - epochStake.epochTimestamp
      const epochReward = stakeAmount
        .times(15)
        .times(epochDuration)
        .div(SECONDS_IN_YEAR * 100)
      return total.plus(epochReward)
    }, BigNumber(0))

    const rewardsItem = {
      stakingProvider: stakingProvider,
      reward: reward,
    }

    rewards.push(rewardsItem)
  })

  return rewards
}

export { getTotalOngoingRewards, getOngoingRewards }
